# Архитектура RooTrace

## Содержание

1. [Обзор](#обзор)
2. [Железный мост — безотказная синхронизация](#железный-мост)
3. [UUID-маркеры и хирургическая очистка](#uuid-маркеры)
4. [Автоматический Rollback](#автоматический-rollback)
5. [Интеграция с MCP](#интеграция-с-mcp)
6. [Безопасность](#безопасность)
7. [Производительность](#производительность)

---

## Обзор

RooTrace — это расширение для VS Code, предназначенное для отладки и трассировки кода. В версии 0.0.1 внедрен **Железный мост** — система безотказной файловой синхронизации через блокировки.

### Ключевые компоненты

- **Extension (HTTP Server)** - принимает логи от приложения
- **MCP Server** - предоставляет инструменты для AI-ассистента
- **SharedLogStorage** - хранилище с файловыми блокировками
- **Code Injector** - инъекция проб с UUID-маркерами и rollback
- **File Lock Utils** - файловые блокировки для предотвращения race conditions
- **Rootrace Dir Utils** - управление директорией `.rootrace` для хранения конфигурации и логов

---

## Железный мост

### Проблема

При одновременной записи логов из HTTP-сервера (Extension) и чтении из MCP-сервера возникают:
- Race conditions (гонки данных)
- Потеря данных при одновременном доступе
- Неконсистентное состояние файла `.rootrace/ai_debug_logs.json`

### Решение

**Файловые блокировки** (`file-lock-utils.ts`):
```typescript
export async function withFileLock<T>(
  filePath: string,
  operation: () => Promise<T>
): Promise<T> {
  // Операции для одного файла выполняются последовательно через очередь
  // Операции для разных файлов могут выполняться параллельно
}
```

**Режим Observer** (`shared-log-storage.ts`):
- `fs.watchFile` отслеживает изменения файла логов (интервал 200 мс, debounce 100 мс)
- MCP-сервер автоматически синхронизируется при изменениях
- Extension (Writer) сразу сбрасывает данные на диск через `addLog()`
- MCP (Reader) загружает данные из файла перед возвратом через `getLogs()`

**Хранение файлов:**
- Все файлы конфигурации и логов хранятся в директории `.rootrace/` в корне проекта
- Файл логов: `.rootrace/ai_debug_logs.json`
- Конфигурация: `.rootrace/ai_debug_config`
- Порт сервера: `.rootrace/debug_port`
- Файлы одобрения: `.rootrace/allow-read-runtime-logs.json`, `.rootrace/allow-auto-debug.json`
- Директория `.rootrace` автоматически добавляется в `.gitignore`

**Гибридный контекст**:
```typescript
// Extension контекст (Writer)
async addLog(log: RuntimeLog): Promise<void> {
  await this.loadFromFile(); // Синхронизируемся перед добавлением
  this.logs.push(log);
  await this.saveToFile(this.logs); // Сразу сбрасываем на диск в .rootrace/
}

// MCP контекст (Reader)
async getLogs(): Promise<RuntimeLog[]> {
  await this.loadFromFile(); // Загружаем из файла .rootrace/ перед отдачей
  return [...this.logs];
}
```

**Преимущества**:
- Никаких race conditions: `withFileLock` гарантирует последовательный доступ
- Нет потери данных: все операции синхронизированы через файловую систему
- Zero-Latency: `fs.watchFile` подхватывает изменения быстрее, чем пользователь переключит вкладку
- Надежность: система работает на уровне файловой системы, даже если VS Code зависнет

---

## UUID-маркеры

### Проблема

Старый метод удаления проб по индексам строк был ненадежен:
- При изменении кода вокруг пробы индексы "плыли"
- Невозможно было точно идентифицировать пробу после редактирования
- Риск удаления пользовательского кода вместо пробы

### Решение

**Формат маркеров**:
```typescript
// RooTrace [id: a1b2] Hypothesis H1: message
...код пробы...
// RooTrace [id: a1b2]: end
```

**Генерация ID**:
```typescript
const probeId = Math.random().toString(36).substring(2, 6); // Короткий, но уникальный
```

**Хирургическое удаление**:
```typescript
// Регулярка ищет всё от стартового маркера до конечного
const probeRegex = /(\/\/\s*RooTrace\s*\[id:\s*[a-z0-9]+\].*?[\s\S]*?\/\/\s*RooTrace\s*\[id:\s*[a-z0-9]+\]:\s*end)|(#\s*RooTrace\s*\[id:\s*[a-z0-9]+\].*?[\s\S]*?#\s*RooTrace\s*\[id:\s*[a-z0-9]+\]:\s*end)/g;
```

**Преимущества**:
- Устойчивость к сдвигам: маркеры находятся в любом месте файла
- Атомарность: благодаря `withFileLock`, файл не может быть прочитан в промежуточном состоянии
- Безопасность: удаляются только блоки с маркерами RooTrace, пользовательский код не затрагивается

---

## Автоматический Rollback

### Проблема

Если бот вставит код, который не компилируется, файл остается в битом состоянии.

### Решение

Проверка синтаксиса выполняется ПОСЛЕ записи, но ПЕРЕД фиксацией результата:

```typescript
// Записываем измененное содержимое
await fs.promises.writeFile(safeFilePath, newContent, 'utf8');

// Проверяем синтаксис ПОСЛЕ записи
const syntaxCheck = await validateSyntax(safeFilePath, language);

// Если синтаксис сломан - откатываем файл немедленно!
if (!syntaxCheck.passed) {
  await fs.promises.writeFile(safeFilePath, originalContent, 'utf8');
  return { success: false, rollback: true };
}
```

**Преимущества**:
- Пользователь не видит "красных" ошибок в терминале
- Файл автоматически возвращается в исходное состояние
- Бот получает ошибку и пробует другую гипотезу, не оставляя мусора

---

## Интеграция с MCP

### Архитектура

```
Roo Code/Cline → MCP Client (stdio) → RooTrace MCP Server → SharedLogStorage (Железный мост) → .rootrace/ai_debug_logs.json
```

### MCP-инструменты

1. **`read_runtime_logs`** - чтение логов (с загрузкой из файла через блокировку, требует одобрения пользователя)
2. **`get_debug_status`** - статус отладки (проверка работоспособности сервера и тест записи/чтения)
3. **`clear_logs`** - очистка только логов (без удаления проб)
4. **`clear_session`** - очистка сессии (удаление проб + обнуление логов)
5. **`inject_probes`** - инъекция одной пробы (с UUID-маркерами и rollback, ⚠️ запрещено для Python)
6. **`inject_multiple_probes`** - инъекция нескольких проб за раз (⚠️ запрещено для Python)
7. **`show_user_instructions`** - показ инструкций пользователю с кнопками

### Протокол отладки (9 фаз: 0-8)

AI Debugger следует строгому протоколу из 9 фаз:

0. **TODO List** - Создание краткого списка задач (макс. 5-7 слов на задачу, ADHD-friendly)
1. **INIT** - Проверка статуса сервера RooTrace и тест записи/чтения
2. **SYSTEM CHECK & NETWORK DISCOVERY** - Обнаружение порта из `.debug_port`, определение Docker окружения, проверка Docker bridge (`host.docker.internal` или `172.17.0.1`)
2.2. **SMOKE TEST** - Обязательная проверка соединения реальным тестовым логом из целевого окружения (Docker или локального). Если тест не прошел, система не продолжает к Phase 3
3. **HYPOTHESES** - Формирование 3-5 проверяемых гипотез (H1-H5)
4. **INSTRUMENTATION** - Инъекция проб с UUID-маркерами (после мета-когнитивной проверки)
5. **WAIT** - Ожидание действий пользователя (запуск кода и воспроизведение бага) или авто-отладка
6. **DATA** - Анализ логов (синхронизированных через Железный мост)
7. **FIX** - Предложение и применение исправления (цикл проверки)
8. **CLEANUP** - Очистка сессии только после подтверждения

**Критичность Smoke Test (Phase 2.2):**
- Предотвращает трату времени и токенов на работу с неработающей сетью
- Обеспечивает обратную связь (feedback loop) - AI не просто "думает", что соединение работает, а доказывает это реальными данными
- Штраф за пропуск smoke test: +10 баллов (CRITICAL FAILURE)

### Мета-когнитивное управление

Перед каждым изменением кода AI проводит внутреннюю проверку через экспертную панель:

- **Аналитик**: Проверяет scope переменных, импорты, экономию токенов, пустоту массивов
- **Критик**: Ищет места, где код упадет (импорты, scope, синтаксис, производительность)
- **Изобретатель**: Оптимизирует для лаконичности (The 5-Line Rule)
- **Профессор**: Проверяет соответствие стандартам, вредные привычки (`print()`), галлюцинации перевода
- **Скептик**: Проверяет гипотезы на основе данных (только после Phase 6)

Это предотвращает ошибки компиляции и улучшает качество проб.

### Правила гигиены кода

Все пробы следуют строгим правилам гигиены кода:

1. **Zero-Dependency Injections**: Используются только стандартные библиотеки или то, что уже есть в файле
2. **Metadata Abstraction**: Метаданные в `state`, а не в `message`
3. **The 5-Line Rule**: Проба не должна превышать 5-7 строк
4. **Асинхронность**: Не блокирует основной поток (Go: `go func()`, Python: `timeout=5.0`)
5. **Метрики количества**: Включает `len(array)` и флаг `is_empty` для массивов/списков
6. **Оптимизация импортов**: Не дублирует `json` если он уже импортирован в файле
7. **Session Binding**: Включает `sessionId` в `state` и в имена временных файлов

### Автоматическая регистрация

При активации расширения:
1. Автоматически детектируется установленное расширение (Roo Code или Roo Cline)
2. Создается конфигурация в файле `.roo/mcp.json`
3. Создается директория `.rootrace/` и добавляется в `.gitignore`
4. Создается файл `.rootrace/debug_port` с номером порта (по умолчанию `51234`)
5. Все инструменты становятся доступны для AI-ассистента
6. Процесс полностью автоматизирован (Zero-Config)
7. RoleManager загружает промпты из `prompts/ai-debugger-prompt.en.md` (приоритет) или `prompts/ai-debugger-prompt.md` (fallback)
8. Watcher отслеживает изменения в обоих файлах и автоматически обновляет `.roomodes`

### Динамическое обнаружение сети

Перед началом инструментации (Phase 2) система автоматически:
1. **Обнаруживает порт**: Читает `.rootrace/debug_port` или `.debug_port` в корне проекта
2. **Определяет окружение**: Проверяет наличие Docker через `docker ps`
3. **Проверяет Docker bridge**: Выполняет `docker exec curl` для проверки доступности `host.docker.internal` или `172.17.0.1`
4. **Smoke Test (Phase 2.2)**: Отправляет тестовый лог из целевого окружения и проверяет его получение
5. **STOP/GO**: Если smoke test не прошел, система не продолжает к инструментации

Все пробы используют обнаруженные `FINAL_HOST` и `ACTUAL_PORT` вместо хардкода `localhost:51234`.

### Система одобрения для чтения логов

Для безопасности чтение логов требует явного одобрения пользователя:
- **Краткосрочное одобрение**: `.rootrace/allow-read-runtime-logs.json` (действует 2 минуты)
- **Долгосрочное одобрение**: `.rootrace/allow-auto-debug.json` (действует 5 минут)
- Одобрение создается при нажатии кнопки "Прочитать логи" в UI
- MCP-сервер проверяет наличие и срок действия одобрения перед чтением логов

---

## Безопасность

### Валидация путей к файлам

```typescript
function sanitizeFilePath(inputPath: string): string {
  PROJECT_ROOT = getProjectRoot();
  const resolved = path.resolve(PROJECT_ROOT, inputPath);
  const normalized = path.normalize(resolved);
  if (!normalized.startsWith(PROJECT_ROOT + path.sep)) {
    throw new Error(`Invalid file path: path traversal detected`);
  }
  return normalized;
}
```

### Защита от path traversal

- Все пути разрешаются относительно корня проекта
- Проверка, что результирующий путь находится внутри проекта
- Использование `path.normalize()` для нормализации путей
- Все файлы конфигурации хранятся в `.rootrace/` директории

### Защита от редактирования без резервной копии

Перед редактированием файлов система проверяет наличие резервной копии:
- **Git репозиторий**: Требуется коммит перед первым редактированием файла
- **Без git**: Требуется создание `.bak` копии файла
- Проверка выполняется один раз на файл в сессии
- Это гарантирует возможность отката изменений

### Валидация параметров

- Проверка типа данных (string, number, boolean)
- Проверка диапазонов значений
- Проверка обязательных параметров
- Экранирование специальных символов в сообщениях

---

## Производительность

### Индексация для быстрого поиска

```typescript
private hypothesisIndex: Map<string, number[]> = new Map();
private timestampIndex: Map<number, number[]> = new Map();
```

- Поиск по гипотезе: O(1) вместо O(n)
- Поиск по дате: O(1) вместо O(n)
- Автоматическое обновление при добавлении логов

### Ограничение размера

- Лимит логов: 1000 записей по умолчанию (настраивается через `rooTrace.maxLogs`, диапазон: 100-10000)
- Автоматическая обрезка старых записей
- Пересоздание индексов при обрезке
- Debounce для watcher'а файла: 100 мс (оптимизация производительности)

### Асинхронность

- Все I/O операции асинхронные (`fs.promises`)
- Не блокирует основной поток выполнения
- Позволяет выполнять другие операции во время I/O

---

## Технический стек

- **Язык**: TypeScript
- **Платформа**: VS Code Extension API
- **Протокол**: Model Context Protocol (MCP)
- **Хранение данных**: JSON файлы в директории `.rootrace/` с файловыми блокировками
- **Асинхронность**: async/await, Promises
- **Безопасность**: валидация, санитизация, блокировки, rollback
- **Синхронизация**: fs.watchFile, файловые блокировки

---

## Принципы проектирования

1. **Безопасность превыше всего** — все пользовательские данные валидируются
2. **Асинхронность** — все I/O операции асинхронные
3. **Инкапсуляция** — внутреннее состояние защищено
4. **Модульность** — компоненты независимы
5. **Надежность** — обработка ошибок, rollback, восстановление
6. **Производительность** — индексы и оптимизации
7. **Безотказность** — файловые блокировки, синхронизация, UUID-маркеры
