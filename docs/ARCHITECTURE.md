# Архитектура RooTrace

## Содержание

1. [Обзор](#обзор)
2. [Железный мост — безотказная синхронизация](#железный-мост)
3. [UUID-маркеры и хирургическая очистка](#uuid-маркеры)
4. [Автоматический Rollback](#автоматический-rollback)
5. [Интеграция с MCP](#интеграция-с-mcp)
6. [Безопасность](#безопасность)
7. [Производительность](#производительность)

---

## Обзор

RooTrace — это расширение для VS Code, предназначенное для отладки и трассировки кода. В версии 1.0.0 внедрен **Железный мост** — система безотказной файловой синхронизации через блокировки.

### Ключевые компоненты

- **Extension (HTTP Server)** - принимает логи от приложения
- **MCP Server** - предоставляет инструменты для AI-ассистента
- **SharedLogStorage** - хранилище с файловыми блокировками
- **Code Injector** - инъекция проб с UUID-маркерами и rollback
- **File Lock Utils** - файловые блокировки для предотвращения race conditions

---

## Железный мост

### Проблема

При одновременной записи логов из HTTP-сервера (Extension) и чтении из MCP-сервера возникают:
- Race conditions (гонки данных)
- Потеря данных при одновременном доступе
- Неконсистентное состояние файла `.ai_debug_logs.json`

### Решение

**Файловые блокировки** (`file-lock-utils.ts`):
```typescript
export async function withFileLock<T>(
  filePath: string,
  operation: () => Promise<T>
): Promise<T> {
  // Операции для одного файла выполняются последовательно через очередь
  // Операции для разных файлов могут выполняться параллельно
}
```

**Режим Observer** (`shared-log-storage.ts`):
- `fs.watchFile` отслеживает изменения файла логов (интервал 200 мс)
- MCP-сервер автоматически синхронизируется при изменениях
- Extension (Writer) сразу сбрасывает данные на диск через `addLog()`
- MCP (Reader) загружает данные из файла перед возвратом через `getLogs()`

**Гибридный контекст**:
```typescript
// Extension контекст (Writer)
async addLog(log: RuntimeLog): Promise<void> {
  await this.loadFromFile(); // Синхронизируемся перед добавлением
  this.logs.push(log);
  await this.saveToFile(this.logs); // Сразу сбрасываем на диск
}

// MCP контекст (Reader)
async getLogs(): Promise<RuntimeLog[]> {
  await this.loadFromFile(); // Загружаем из файла перед отдачей
  return [...this.logs];
}
```

**Преимущества**:
- Никаких race conditions: `withFileLock` гарантирует последовательный доступ
- Нет потери данных: все операции синхронизированы через файловую систему
- Zero-Latency: `fs.watchFile` подхватывает изменения быстрее, чем пользователь переключит вкладку
- Надежность: система работает на уровне файловой системы, даже если VS Code зависнет

---

## UUID-маркеры

### Проблема

Старый метод удаления проб по индексам строк был ненадежен:
- При изменении кода вокруг пробы индексы "плыли"
- Невозможно было точно идентифицировать пробу после редактирования
- Риск удаления пользовательского кода вместо пробы

### Решение

**Формат маркеров**:
```typescript
// RooTrace [id: a1b2] Hypothesis H1: message
...код пробы...
// RooTrace [id: a1b2]: end
```

**Генерация ID**:
```typescript
const probeId = Math.random().toString(36).substring(2, 6); // Короткий, но уникальный
```

**Хирургическое удаление**:
```typescript
// Регулярка ищет всё от стартового маркера до конечного
const probeRegex = /(\/\/\s*RooTrace\s*\[id:\s*[a-z0-9]+\].*?[\s\S]*?\/\/\s*RooTrace\s*\[id:\s*[a-z0-9]+\]:\s*end)|(#\s*RooTrace\s*\[id:\s*[a-z0-9]+\].*?[\s\S]*?#\s*RooTrace\s*\[id:\s*[a-z0-9]+\]:\s*end)/g;
```

**Преимущества**:
- Устойчивость к сдвигам: маркеры находятся в любом месте файла
- Атомарность: благодаря `withFileLock`, файл не может быть прочитан в промежуточном состоянии
- Безопасность: удаляются только блоки с маркерами RooTrace, пользовательский код не затрагивается

---

## Автоматический Rollback

### Проблема

Если бот вставит код, который не компилируется, файл остается в битом состоянии.

### Решение

Проверка синтаксиса выполняется ПОСЛЕ записи, но ПЕРЕД фиксацией результата:

```typescript
// Записываем измененное содержимое
await fs.promises.writeFile(safeFilePath, newContent, 'utf8');

// Проверяем синтаксис ПОСЛЕ записи
const syntaxCheck = await validateSyntax(safeFilePath, language);

// Если синтаксис сломан - откатываем файл немедленно!
if (!syntaxCheck.passed) {
  await fs.promises.writeFile(safeFilePath, originalContent, 'utf8');
  return { success: false, rollback: true };
}
```

**Преимущества**:
- Пользователь не видит "красных" ошибок в терминале
- Файл автоматически возвращается в исходное состояние
- Бот получает ошибку и пробует другую гипотезу, не оставляя мусора

---

## Интеграция с MCP

### Архитектура

```
Roo Code/Cline → MCP Client (stdio) → RooTrace MCP Server → SharedLogStorage (Железный мост) → .ai_debug_logs.json
```

### MCP-инструменты

1. **`read_runtime_logs`** - чтение логов (с загрузкой из файла через блокировку)
2. **`get_debug_status`** - статус отладки
3. **`clear_session`** - очистка сессии (удаление проб + обнуление логов)
4. **`inject_probes`** - инъекция проб (с UUID-маркерами и rollback)
5. **`inject_multiple_probes`** - инъекция нескольких проб за раз
6. **`show_user_instructions`** - показ инструкций пользователю

### Автоматическая регистрация

При активации расширения:
1. Автоматически детектируется установленное расширение (Roo Code или Roo Cline)
2. Создается конфигурация в файле `.roo/mcp.json`
3. Все инструменты становятся доступны для AI-ассистента
4. Процесс полностью автоматизирован (Zero-Config)

---

## Безопасность

### Валидация путей к файлам

```typescript
function sanitizeFilePath(inputPath: string): string {
  PROJECT_ROOT = getProjectRoot();
  const resolved = path.resolve(PROJECT_ROOT, inputPath);
  const normalized = path.normalize(resolved);
  if (!normalized.startsWith(PROJECT_ROOT + path.sep)) {
    throw new Error(`Invalid file path: path traversal detected`);
  }
  return normalized;
}
```

### Защита от path traversal

- Все пути разрешаются относительно корня проекта
- Проверка, что результирующий путь находится внутри проекта
- Использование `path.normalize()` для нормализации путей

### Валидация параметров

- Проверка типа данных (string, number, boolean)
- Проверка диапазонов значений
- Проверка обязательных параметров
- Экранирование специальных символов в сообщениях

---

## Производительность

### Индексация для быстрого поиска

```typescript
private hypothesisIndex: Map<string, number[]> = new Map();
private timestampIndex: Map<number, number[]> = new Map();
```

- Поиск по гипотезе: O(1) вместо O(n)
- Поиск по дате: O(1) вместо O(n)
- Автоматическое обновление при добавлении логов

### Ограничение размера

- Лимит логов: 1000 записей по умолчанию (настраивается через `rooTrace.maxLogs`)
- Автоматическая обрезка старых записей
- Пересоздание индексов при обрезке

### Асинхронность

- Все I/O операции асинхронные (`fs.promises`)
- Не блокирует основной поток выполнения
- Позволяет выполнять другие операции во время I/O

---

## Технический стек

- **Язык**: TypeScript
- **Платформа**: VS Code Extension API
- **Протокол**: Model Context Protocol (MCP)
- **Хранение данных**: JSON файлы с файловыми блокировками
- **Асинхронность**: async/await, Promises
- **Безопасность**: валидация, санитизация, блокировки, rollback
- **Синхронизация**: fs.watchFile, файловые блокировки

---

## Принципы проектирования

1. **Безопасность превыше всего** — все пользовательские данные валидируются
2. **Асинхронность** — все I/O операции асинхронные
3. **Инкапсуляция** — внутреннее состояние защищено
4. **Модульность** — компоненты независимы
5. **Надежность** — обработка ошибок, rollback, восстановление
6. **Производительность** — индексы и оптимизации
7. **Безотказность** — файловые блокировки, синхронизация, UUID-маркеры
